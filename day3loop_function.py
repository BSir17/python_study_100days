#https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/Day06/%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8.md
# for循环
# random模块
# 函数的使用 参数默认值的设置，变参的使用
#用模块管理函数 解决命名冲突的问题
#函数中的函数
sum = 0
#像下面这样写就可以生成从大到小的数组
for x in range(101, 1, -2):  # 可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量,不包含最后一个数101
    print(x)
    sum += x
print(sum)
exit(0)

#######----------------------------------------------------------##########

import random
answer = random.randint(1, 3)  # 1-3之间任一个整数，包含1和3
print(answer)

#######----------------------------------------------------------##########


# 函数
# 函数的参数
# Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持函数的重载
# 函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，
# 所以在下面的代码中我们可以用各种不同的方式去调用add函数，这跟其他很多语言中函数重载的效果是一致的。
from random import randint
def roll_dice(n=2):
    """
    摇色子

    :param n: 色子的个数
    :return: n颗色子点数之和
    """
    total = 0
    for _ in range(n):
        total += randint(1, 6)
    return total


def add(a=0, b=0, c=0):
    return a + b + c


# 在不确定参数个数的时候，我们可以使用可变参数
def add(*args):
    total = 0
    for var in args:
        total += var
    return total

print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
print(add(1, 3, 5, 7, 9))
#######----------------------------------------------------------##########

#用模块管理函数
#我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，
# 由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的
#解决方法：
#通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的命名冲突函数
#eg:

import module1 as m1
import module2 as m2

m1.foo()
m2.foo()

#如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，
# 事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，
# 这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。

#也就是把每个py文件中的可执行语句放在下列语句中
if __name__ == '__main__':
    print('call foo()')
    foo()
    print('call bar()')
    bar()
#######----------------------------------------------------------##########

#函数中的函数
#解读：下列程序中
#if分支中定义了一个变量a，这是一个全局变量
#foo函数中我们定义了变量b，这是一个定义在函数中的局部变量（local variable），
# 属于局部作用域，在foo函数的外部并不能访问到它；
# 但对于foo函数内部的bar函数来说，变量b属于嵌套作用域，在bar函数中我们是可以访问到它
#   bar函数中的变量c属于局部作用域，在bar函数之外是无法访问的
def foo():
	b = 'hello'

	def bar():  # Python中可以在函数内部再定义函数
            c = True
        print(a)                        #a为全局变量
        print(b)                        #b为嵌套作用域
        nonlocal c                          #如果加入这行 则下面那行能运行 意味这c不是局部作用域
        print(c)                        #c为局部作用域

	bar()
    # print(c)  # NameError: name 'c' is not defined


if __name__ == '__main__':
	a = 100
    # print(b)  # NameError: name 'b' is not defined
	foo()



#######----------------------------------------------------------##########
#希望在函数中修改全局变量的值;
def foo():
#可以使用global关键字来指示foo函数中的变量a来自于全局作用域，如果全局作用域中没有a，
# 那么下面一行的代码就会定义变量a并将其置于全局作用域
#如果我们希望函数内部的函数能够修改嵌套作用域中的变量，
# 可以使用nonlocal关键字来指示变量来自于嵌套作用域
	global a
	a = 200
	print(a)  # 200


if __name__ == '__main__':
	a = 100
	foo()
	print(a)  # 200
















